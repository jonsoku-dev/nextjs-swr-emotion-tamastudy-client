/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface BoardCategoryCreateRequest
 */
export interface BoardCategoryCreateRequest {
  /**
   *
   * @type {string}
   * @memberof BoardCategoryCreateRequest
   */
  name: string;
}
/**
 *
 * @export
 * @interface BoardCategoryDto
 */
export interface BoardCategoryDto {
  /**
   *
   * @type {string}
   * @memberof BoardCategoryDto
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof BoardCategoryDto
   */
  categoryId: number;
}
/**
 *
 * @export
 * @interface BoardCategoryUpdateRequest
 */
export interface BoardCategoryUpdateRequest {
  /**
   *
   * @type {string}
   * @memberof BoardCategoryUpdateRequest
   */
  name: string;
}
/**
 *
 * @export
 * @interface BoardCreateRequest
 */
export interface BoardCreateRequest {
  /**
   *
   * @type {string}
   * @memberof BoardCreateRequest
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof BoardCreateRequest
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof BoardCreateRequest
   */
  categoryId: number;
}
/**
 *
 * @export
 * @interface BoardDto
 */
export interface BoardDto {
  /**
   *
   * @type {string}
   * @memberof BoardDto
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof BoardDto
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof BoardDto
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof BoardDto
   */
  title: string;
  /**
   *
   * @type {BoardCategoryDto}
   * @memberof BoardDto
   */
  category: BoardCategoryDto;
  /**
   *
   * @type {UserDto}
   * @memberof BoardDto
   */
  user: UserDto;
  /**
   *
   * @type {string}
   * @memberof BoardDto
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface BoardFlatDto
 */
export interface BoardFlatDto {
  /**
   *
   * @type {string}
   * @memberof BoardFlatDto
   */
  createdAt: string;
  /**
   *
   * @type {number}
   * @memberof BoardFlatDto
   */
  boardId: number;
  /**
   *
   * @type {string}
   * @memberof BoardFlatDto
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof BoardFlatDto
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof BoardFlatDto
   */
  userId: number;
  /**
   *
   * @type {string}
   * @memberof BoardFlatDto
   */
  categoryName: string;
  /**
   *
   * @type {string}
   * @memberof BoardFlatDto
   */
  email: string;
  /**
   *
   * @type {number}
   * @memberof BoardFlatDto
   */
  categoryId: number;
  /**
   *
   * @type {string}
   * @memberof BoardFlatDto
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof BoardFlatDto
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface BoardIds
 */
export interface BoardIds {
  /**
   *
   * @type {number}
   * @memberof BoardIds
   */
  boardId: number;
}
/**
 *
 * @export
 * @interface BoardPagingCondition
 */
export interface BoardPagingCondition {
  /**
   *
   * @type {string}
   * @memberof BoardPagingCondition
   */
  keyword?: string;
  /**
   *
   * @type {string}
   * @memberof BoardPagingCondition
   */
  categoryName?: string;
}
/**
 *
 * @export
 * @interface BoardUpdateRequest
 */
export interface BoardUpdateRequest {
  /**
   *
   * @type {string}
   * @memberof BoardUpdateRequest
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof BoardUpdateRequest
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof BoardUpdateRequest
   */
  categoryId: number;
}
/**
 *
 * @export
 * @interface CommentCreateRequest
 */
export interface CommentCreateRequest {
  /**
   *
   * @type {number}
   * @memberof CommentCreateRequest
   */
  commentId?: number;
  /**
   *
   * @type {string}
   * @memberof CommentCreateRequest
   */
  text: string;
}
/**
 *
 * @export
 * @interface CommentDto
 */
export interface CommentDto {
  /**
   *
   * @type {string}
   * @memberof CommentDto
   */
  createdAt?: string;
  /**
   *
   * @type {boolean}
   * @memberof CommentDto
   */
  isLive?: boolean;
  /**
   *
   * @type {number}
   * @memberof CommentDto
   */
  level?: number;
  /**
   *
   * @type {Array<CommentDto>}
   * @memberof CommentDto
   */
  subComment: Array<CommentDto>;
  /**
   *
   * @type {number}
   * @memberof CommentDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CommentDto
   */
  text?: string;
  /**
   *
   * @type {CommentDto}
   * @memberof CommentDto
   */
  superComment?: CommentDto;
  /**
   *
   * @type {UserDto}
   * @memberof CommentDto
   */
  user?: UserDto;
  /**
   *
   * @type {BoardDto}
   * @memberof CommentDto
   */
  board?: BoardDto;
  /**
   *
   * @type {string}
   * @memberof CommentDto
   */
  updatedAt?: string;
}
/**
 *
 * @export
 * @interface CommentFlatDto
 */
export interface CommentFlatDto {
  /**
   *
   * @type {string}
   * @memberof CommentFlatDto
   */
  createdAt: string;
  /**
   *
   * @type {boolean}
   * @memberof CommentFlatDto
   */
  isLive?: boolean;
  /**
   *
   * @type {number}
   * @memberof CommentFlatDto
   */
  level: number;
  /**
   *
   * @type {number}
   * @memberof CommentFlatDto
   */
  commentId: number;
  /**
   *
   * @type {Array<CommentDto>}
   * @memberof CommentFlatDto
   */
  subComment?: Array<CommentFlatDto>;
  /**
   *
   * @type {string}
   * @memberof CommentFlatDto
   */
  text: string;
  /**
   *
   * @type {CommentDto}
   * @memberof CommentFlatDto
   */
  superComment: CommentDto;
  /**
   *
   * @type {number}
   * @memberof CommentFlatDto
   */
  userId: number;
  /**
   *
   * @type {string}
   * @memberof CommentFlatDto
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof CommentFlatDto
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface CommentResponseDto
 */
export interface CommentResponseDto {
  /**
   *
   * @type {string}
   * @memberof CommentResponseDto
   */
  createdAt: string;
  /**
   *
   * @type {boolean}
   * @memberof CommentResponseDto
   */
  isLive?: boolean;
  /**
   *
   * @type {number}
   * @memberof CommentResponseDto
   */
  level: number;
  /**
   *
   * @type {number}
   * @memberof CommentResponseDto
   */
  commentId: number;
  /**
   *
   * @type {string}
   * @memberof CommentResponseDto
   */
  text: string;
  /**
   *
   * @type {number}
   * @memberof CommentResponseDto
   */
  userId: number;
  /**
   *
   * @type {string}
   * @memberof CommentResponseDto
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof CommentResponseDto
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface CommentUpdateRequest
 */
export interface CommentUpdateRequest {
  /**
   *
   * @type {string}
   * @memberof CommentUpdateRequest
   */
  text: string;
}
/**
 *
 * @export
 * @interface PageBoardFlatDto
 */
export interface PageBoardFlatDto {
  /**
   *
   * @type {number}
   * @memberof PageBoardFlatDto
   */
  number?: number;
  /**
   *
   * @type {number}
   * @memberof PageBoardFlatDto
   */
  numberOfElements?: number;
  /**
   *
   * @type {number}
   * @memberof PageBoardFlatDto
   */
  size?: number;
  /**
   *
   * @type {boolean}
   * @memberof PageBoardFlatDto
   */
  last?: boolean;
  /**
   *
   * @type {number}
   * @memberof PageBoardFlatDto
   */
  totalPages?: number;
  /**
   *
   * @type {Pageable}
   * @memberof PageBoardFlatDto
   */
  pageable?: Pageable;
  /**
   *
   * @type {Sort}
   * @memberof PageBoardFlatDto
   */
  sort?: Sort;
  /**
   *
   * @type {boolean}
   * @memberof PageBoardFlatDto
   */
  first?: boolean;
  /**
   *
   * @type {Array<BoardFlatDto>}
   * @memberof PageBoardFlatDto
   */
  content?: Array<BoardFlatDto>;
  /**
   *
   * @type {number}
   * @memberof PageBoardFlatDto
   */
  totalElements?: number;
  /**
   *
   * @type {boolean}
   * @memberof PageBoardFlatDto
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface PageCommentFlatDto
 */
export interface PageCommentFlatDto {
  /**
   *
   * @type {number}
   * @memberof PageCommentFlatDto
   */
  number?: number;
  /**
   *
   * @type {number}
   * @memberof PageCommentFlatDto
   */
  numberOfElements?: number;
  /**
   *
   * @type {number}
   * @memberof PageCommentFlatDto
   */
  size?: number;
  /**
   *
   * @type {boolean}
   * @memberof PageCommentFlatDto
   */
  last?: boolean;
  /**
   *
   * @type {number}
   * @memberof PageCommentFlatDto
   */
  totalPages?: number;
  /**
   *
   * @type {Pageable}
   * @memberof PageCommentFlatDto
   */
  pageable?: Pageable;
  /**
   *
   * @type {Sort}
   * @memberof PageCommentFlatDto
   */
  sort?: Sort;
  /**
   *
   * @type {boolean}
   * @memberof PageCommentFlatDto
   */
  first?: boolean;
  /**
   *
   * @type {Array<CommentFlatDto>}
   * @memberof PageCommentFlatDto
   */
  content?: Array<CommentFlatDto>;
  /**
   *
   * @type {number}
   * @memberof PageCommentFlatDto
   */
  totalElements?: number;
  /**
   *
   * @type {boolean}
   * @memberof PageCommentFlatDto
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface Pageable
 */
export interface Pageable {
  /**
   *
   * @type {boolean}
   * @memberof Pageable
   */
  paged?: boolean;
  /**
   *
   * @type {number}
   * @memberof Pageable
   */
  pageNumber?: number;
  /**
   *
   * @type {number}
   * @memberof Pageable
   */
  offset?: number;
  /**
   *
   * @type {number}
   * @memberof Pageable
   */
  pageSize?: number;
  /**
   *
   * @type {boolean}
   * @memberof Pageable
   */
  unpaged?: boolean;
  /**
   *
   * @type {Sort}
   * @memberof Pageable
   */
  sort?: Sort;
}
/**
 *
 * @export
 * @interface Sort
 */
export interface Sort {
  /**
   *
   * @type {boolean}
   * @memberof Sort
   */
  unsorted?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Sort
   */
  sorted?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Sort
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  roles: string;
  /**
   *
   * @type {number}
   * @memberof UserDto
   */
  userId: number;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  refreshToken: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  updatedAt?: string;
}
/**
 *
 * @export
 * @interface UserJoinRequestDto
 */
export interface UserJoinRequestDto {
  /**
   *
   * @type {string}
   * @memberof UserJoinRequestDto
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof UserJoinRequestDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserJoinRequestDto
   */
  username: string;
}
/**
 *
 * @export
 * @interface UserJoinResponseDto
 */
export interface UserJoinResponseDto {
  /**
   *
   * @type {number}
   * @memberof UserJoinResponseDto
   */
  userId: number;
  /**
   *
   * @type {string}
   * @memberof UserJoinResponseDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserJoinResponseDto
   */
  username: string;
}
/**
 *
 * @export
 * @interface UserLoginRequestDto
 */
export interface UserLoginRequestDto {
  /**
   *
   * @type {string}
   * @memberof UserLoginRequestDto
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof UserLoginRequestDto
   */
  email: string;
}
/**
 *
 * @export
 * @interface UserLoginResponseDto
 */
export interface UserLoginResponseDto {
  /**
   *
   * @type {number}
   * @memberof UserLoginResponseDto
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UserLoginResponseDto
   */
  token: string;
  /**
   *
   * @type {string}
   * @memberof UserLoginResponseDto
   */
  refreshToken: string;
}

/**
 * BoardApiControllerApi - axios parameter creator
 * @export
 */
export const BoardApiControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {BoardCreateRequest} boardCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBoard: async (boardCreateRequest: BoardCreateRequest, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'boardCreateRequest' is not null or undefined
      assertParamExists('createBoard', 'boardCreateRequest', boardCreateRequest);
      const localVarPath = `/api/v1/board`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(boardCreateRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} boardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBoard: async (boardId: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists('deleteBoard', 'boardId', boardId);
      const localVarPath = `/api/v1/board/{boardId}`.replace(`{${'boardId'}}`, encodeURIComponent(String(boardId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBo: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/bo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} boardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBoard: async (boardId: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists('getBoard', 'boardId', boardId);
      const localVarPath = `/api/v1/board/{boardId}`.replace(`{${'boardId'}}`, encodeURIComponent(String(boardId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBoardIds: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/board/ids`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {BoardPagingCondition} boardPagingCondition
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBoards: async (
      boardPagingCondition: BoardPagingCondition,
      pageable: Pageable,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardPagingCondition' is not null or undefined
      assertParamExists('getBoards', 'boardPagingCondition', boardPagingCondition);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getBoards', 'pageable', pageable);
      const localVarPath = `/api/v2/board`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (boardPagingCondition !== undefined) {
        localVarQueryParameter['boardPagingCondition'] = boardPagingCondition;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {BoardPagingCondition} boardPagingCondition
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBoardsV1: async (
      boardPagingCondition: BoardPagingCondition,
      pageable: Pageable,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardPagingCondition' is not null or undefined
      assertParamExists('getBoardsV1', 'boardPagingCondition', boardPagingCondition);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getBoardsV1', 'pageable', pageable);
      const localVarPath = `/api/v1/board`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (boardPagingCondition !== undefined) {
        localVarQueryParameter['boardPagingCondition'] = boardPagingCondition;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} boardId
     * @param {BoardUpdateRequest} boardUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBoard: async (
      boardId: number,
      boardUpdateRequest: BoardUpdateRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists('updateBoard', 'boardId', boardId);
      // verify required parameter 'boardUpdateRequest' is not null or undefined
      assertParamExists('updateBoard', 'boardUpdateRequest', boardUpdateRequest);
      const localVarPath = `/api/v1/board/{boardId}`.replace(`{${'boardId'}}`, encodeURIComponent(String(boardId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(boardUpdateRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * BoardApiControllerApi - functional programming interface
 * @export
 */
export const BoardApiControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BoardApiControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {BoardCreateRequest} boardCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBoard(
      boardCreateRequest: BoardCreateRequest,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardFlatDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createBoard(boardCreateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} boardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteBoard(
      boardId: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBoard(boardId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBo(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} boardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBoard(
      boardId: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardFlatDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBoard(boardId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBoardIds(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BoardIds>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBoardIds(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {BoardPagingCondition} boardPagingCondition
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBoards(
      boardPagingCondition: BoardPagingCondition,
      pageable: Pageable,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageBoardFlatDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBoards(boardPagingCondition, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {BoardPagingCondition} boardPagingCondition
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBoardsV1(
      boardPagingCondition: BoardPagingCondition,
      pageable: Pageable,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageBoardFlatDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBoardsV1(boardPagingCondition, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} boardId
     * @param {BoardUpdateRequest} boardUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateBoard(
      boardId: number,
      boardUpdateRequest: BoardUpdateRequest,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardFlatDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateBoard(boardId, boardUpdateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * BoardApiControllerApi - factory interface
 * @export
 */
export const BoardApiControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BoardApiControllerApiFp(configuration);
  return {
    /**
     *
     * @param {BoardCreateRequest} boardCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBoard(boardCreateRequest: BoardCreateRequest, options?: any): AxiosPromise<BoardFlatDto> {
      return localVarFp.createBoard(boardCreateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} boardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBoard(boardId: number, options?: any): AxiosPromise<object> {
      return localVarFp.deleteBoard(boardId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBo(options?: any): AxiosPromise<object> {
      return localVarFp.getBo(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} boardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBoard(boardId: number, options?: any): AxiosPromise<BoardFlatDto> {
      return localVarFp.getBoard(boardId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBoardIds(options?: any): AxiosPromise<Array<BoardIds>> {
      return localVarFp.getBoardIds(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {BoardPagingCondition} boardPagingCondition
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBoards(
      boardPagingCondition: BoardPagingCondition,
      pageable: Pageable,
      options?: any
    ): AxiosPromise<PageBoardFlatDto> {
      return localVarFp.getBoards(boardPagingCondition, pageable, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {BoardPagingCondition} boardPagingCondition
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBoardsV1(
      boardPagingCondition: BoardPagingCondition,
      pageable: Pageable,
      options?: any
    ): AxiosPromise<PageBoardFlatDto> {
      return localVarFp
        .getBoardsV1(boardPagingCondition, pageable, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} boardId
     * @param {BoardUpdateRequest} boardUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBoard(boardId: number, boardUpdateRequest: BoardUpdateRequest, options?: any): AxiosPromise<BoardFlatDto> {
      return localVarFp.updateBoard(boardId, boardUpdateRequest, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * BoardApiControllerApi - object-oriented interface
 * @export
 * @class BoardApiControllerApi
 * @extends {BaseAPI}
 */
export class BoardApiControllerApi extends BaseAPI {
  /**
   *
   * @param {BoardCreateRequest} boardCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardApiControllerApi
   */
  public createBoard(boardCreateRequest: BoardCreateRequest, options?: any) {
    return BoardApiControllerApiFp(this.configuration)
      .createBoard(boardCreateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} boardId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardApiControllerApi
   */
  public deleteBoard(boardId: number, options?: any) {
    return BoardApiControllerApiFp(this.configuration)
      .deleteBoard(boardId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardApiControllerApi
   */
  public getBo(options?: any) {
    return BoardApiControllerApiFp(this.configuration)
      .getBo(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} boardId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardApiControllerApi
   */
  public getBoard(boardId: number, options?: any) {
    return BoardApiControllerApiFp(this.configuration)
      .getBoard(boardId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardApiControllerApi
   */
  public getBoardIds(options?: any) {
    return BoardApiControllerApiFp(this.configuration)
      .getBoardIds(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {BoardPagingCondition} boardPagingCondition
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardApiControllerApi
   */
  public getBoards(boardPagingCondition: BoardPagingCondition, pageable: Pageable, options?: any) {
    return BoardApiControllerApiFp(this.configuration)
      .getBoards(boardPagingCondition, pageable, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {BoardPagingCondition} boardPagingCondition
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardApiControllerApi
   */
  public getBoardsV1(boardPagingCondition: BoardPagingCondition, pageable: Pageable, options?: any) {
    return BoardApiControllerApiFp(this.configuration)
      .getBoardsV1(boardPagingCondition, pageable, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} boardId
   * @param {BoardUpdateRequest} boardUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardApiControllerApi
   */
  public updateBoard(boardId: number, boardUpdateRequest: BoardUpdateRequest, options?: any) {
    return BoardApiControllerApiFp(this.configuration)
      .updateBoard(boardId, boardUpdateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BoardCategoryApiControllerApi - axios parameter creator
 * @export
 */
export const BoardCategoryApiControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {BoardCategoryCreateRequest} boardCategoryCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCategory: async (
      boardCategoryCreateRequest: BoardCategoryCreateRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardCategoryCreateRequest' is not null or undefined
      assertParamExists('createCategory', 'boardCategoryCreateRequest', boardCategoryCreateRequest);
      const localVarPath = `/api/v1/category`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        boardCategoryCreateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCategory: async (categoryId: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'categoryId' is not null or undefined
      assertParamExists('deleteCategory', 'categoryId', categoryId);
      const localVarPath = `/api/v1/category/{categoryId}`.replace(
        `{${'categoryId'}}`,
        encodeURIComponent(String(categoryId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategories: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/category`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategory: async (categoryId: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'categoryId' is not null or undefined
      assertParamExists('getCategory', 'categoryId', categoryId);
      const localVarPath = `/api/v1/category/{categoryId}`.replace(
        `{${'categoryId'}}`,
        encodeURIComponent(String(categoryId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} categoryId
     * @param {BoardCategoryUpdateRequest} boardCategoryUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCategory: async (
      categoryId: number,
      boardCategoryUpdateRequest: BoardCategoryUpdateRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'categoryId' is not null or undefined
      assertParamExists('updateCategory', 'categoryId', categoryId);
      // verify required parameter 'boardCategoryUpdateRequest' is not null or undefined
      assertParamExists('updateCategory', 'boardCategoryUpdateRequest', boardCategoryUpdateRequest);
      const localVarPath = `/api/v1/category/{categoryId}`.replace(
        `{${'categoryId'}}`,
        encodeURIComponent(String(categoryId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        boardCategoryUpdateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * BoardCategoryApiControllerApi - functional programming interface
 * @export
 */
export const BoardCategoryApiControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BoardCategoryApiControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {BoardCategoryCreateRequest} boardCategoryCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCategory(
      boardCategoryCreateRequest: BoardCategoryCreateRequest,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardCategoryDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(boardCategoryCreateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCategory(
      categoryId: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(categoryId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCategories(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BoardCategoryDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCategory(
      categoryId: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardCategoryDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(categoryId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} categoryId
     * @param {BoardCategoryUpdateRequest} boardCategoryUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCategory(
      categoryId: number,
      boardCategoryUpdateRequest: BoardCategoryUpdateRequest,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardCategoryDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(
        categoryId,
        boardCategoryUpdateRequest,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * BoardCategoryApiControllerApi - factory interface
 * @export
 */
export const BoardCategoryApiControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BoardCategoryApiControllerApiFp(configuration);
  return {
    /**
     *
     * @param {BoardCategoryCreateRequest} boardCategoryCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCategory(
      boardCategoryCreateRequest: BoardCategoryCreateRequest,
      options?: any
    ): AxiosPromise<BoardCategoryDto> {
      return localVarFp.createCategory(boardCategoryCreateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCategory(categoryId: number, options?: any): AxiosPromise<object> {
      return localVarFp.deleteCategory(categoryId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategories(options?: any): AxiosPromise<Array<BoardCategoryDto>> {
      return localVarFp.getCategories(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategory(categoryId: number, options?: any): AxiosPromise<BoardCategoryDto> {
      return localVarFp.getCategory(categoryId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} categoryId
     * @param {BoardCategoryUpdateRequest} boardCategoryUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCategory(
      categoryId: number,
      boardCategoryUpdateRequest: BoardCategoryUpdateRequest,
      options?: any
    ): AxiosPromise<BoardCategoryDto> {
      return localVarFp
        .updateCategory(categoryId, boardCategoryUpdateRequest, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * BoardCategoryApiControllerApi - object-oriented interface
 * @export
 * @class BoardCategoryApiControllerApi
 * @extends {BaseAPI}
 */
export class BoardCategoryApiControllerApi extends BaseAPI {
  /**
   *
   * @param {BoardCategoryCreateRequest} boardCategoryCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardCategoryApiControllerApi
   */
  public createCategory(boardCategoryCreateRequest: BoardCategoryCreateRequest, options?: any) {
    return BoardCategoryApiControllerApiFp(this.configuration)
      .createCategory(boardCategoryCreateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} categoryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardCategoryApiControllerApi
   */
  public deleteCategory(categoryId: number, options?: any) {
    return BoardCategoryApiControllerApiFp(this.configuration)
      .deleteCategory(categoryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardCategoryApiControllerApi
   */
  public getCategories(options?: any) {
    return BoardCategoryApiControllerApiFp(this.configuration)
      .getCategories(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} categoryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardCategoryApiControllerApi
   */
  public getCategory(categoryId: number, options?: any) {
    return BoardCategoryApiControllerApiFp(this.configuration)
      .getCategory(categoryId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} categoryId
   * @param {BoardCategoryUpdateRequest} boardCategoryUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardCategoryApiControllerApi
   */
  public updateCategory(categoryId: number, boardCategoryUpdateRequest: BoardCategoryUpdateRequest, options?: any) {
    return BoardCategoryApiControllerApiFp(this.configuration)
      .updateCategory(categoryId, boardCategoryUpdateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CommentApiControllerApi - axios parameter creator
 * @export
 */
export const CommentApiControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {number} boardId
     * @param {CommentCreateRequest} commentCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createComment: async (
      boardId: number,
      commentCreateRequest: CommentCreateRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists('createComment', 'boardId', boardId);
      // verify required parameter 'commentCreateRequest' is not null or undefined
      assertParamExists('createComment', 'commentCreateRequest', commentCreateRequest);
      const localVarPath = `/api/v1/board/{boardId}/comment`.replace(
        `{${'boardId'}}`,
        encodeURIComponent(String(boardId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(commentCreateRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} boardId
     * @param {number} commentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComment: async (boardId: number, commentId: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists('deleteComment', 'boardId', boardId);
      // verify required parameter 'commentId' is not null or undefined
      assertParamExists('deleteComment', 'commentId', commentId);
      const localVarPath = `/api/v1/board/{boardId}/comment/{commentId}`
        .replace(`{${'boardId'}}`, encodeURIComponent(String(boardId)))
        .replace(`{${'commentId'}}`, encodeURIComponent(String(commentId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} boardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAll: async (boardId: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists('findAll', 'boardId', boardId);
      const localVarPath = `/api/v1/board/{boardId}/comment`.replace(
        `{${'boardId'}}`,
        encodeURIComponent(String(boardId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} boardId
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchPage: async (boardId: number, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists('searchPage', 'boardId', boardId);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('searchPage', 'pageable', pageable);
      const localVarPath = `/api/v1/board/{boardId}/comment/paging`.replace(
        `{${'boardId'}}`,
        encodeURIComponent(String(boardId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} boardId
     * @param {number} commentId
     * @param {CommentUpdateRequest} commentUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateComment: async (
      boardId: number,
      commentId: number,
      commentUpdateRequest: CommentUpdateRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists('updateComment', 'boardId', boardId);
      // verify required parameter 'commentId' is not null or undefined
      assertParamExists('updateComment', 'commentId', commentId);
      // verify required parameter 'commentUpdateRequest' is not null or undefined
      assertParamExists('updateComment', 'commentUpdateRequest', commentUpdateRequest);
      const localVarPath = `/api/v1/board/{boardId}/comment/{commentId}`
        .replace(`{${'boardId'}}`, encodeURIComponent(String(boardId)))
        .replace(`{${'commentId'}}`, encodeURIComponent(String(commentId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(commentUpdateRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * CommentApiControllerApi - functional programming interface
 * @export
 */
export const CommentApiControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CommentApiControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {number} boardId
     * @param {CommentCreateRequest} commentCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createComment(
      boardId: number,
      commentCreateRequest: CommentCreateRequest,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(boardId, commentCreateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} boardId
     * @param {number} commentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteComment(
      boardId: number,
      commentId: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(boardId, commentId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} boardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findAll(
      boardId: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommentResponseDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findAll(boardId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} boardId
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchPage(
      boardId: number,
      pageable: Pageable,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageCommentFlatDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchPage(boardId, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} boardId
     * @param {number} commentId
     * @param {CommentUpdateRequest} commentUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateComment(
      boardId: number,
      commentId: number,
      commentUpdateRequest: CommentUpdateRequest,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentFlatDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateComment(
        boardId,
        commentId,
        commentUpdateRequest,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * CommentApiControllerApi - factory interface
 * @export
 */
export const CommentApiControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CommentApiControllerApiFp(configuration);
  return {
    /**
     *
     * @param {number} boardId
     * @param {CommentCreateRequest} commentCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createComment(
      boardId: number,
      commentCreateRequest: CommentCreateRequest,
      options?: any
    ): AxiosPromise<CommentDto> {
      return localVarFp
        .createComment(boardId, commentCreateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} boardId
     * @param {number} commentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComment(boardId: number, commentId: number, options?: any): AxiosPromise<object> {
      return localVarFp.deleteComment(boardId, commentId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} boardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAll(boardId: number, options?: any): AxiosPromise<Array<CommentResponseDto>> {
      return localVarFp.findAll(boardId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} boardId
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchPage(boardId: number, pageable: Pageable, options?: any): AxiosPromise<PageCommentFlatDto> {
      return localVarFp.searchPage(boardId, pageable, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} boardId
     * @param {number} commentId
     * @param {CommentUpdateRequest} commentUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateComment(
      boardId: number,
      commentId: number,
      commentUpdateRequest: CommentUpdateRequest,
      options?: any
    ): AxiosPromise<CommentFlatDto> {
      return localVarFp
        .updateComment(boardId, commentId, commentUpdateRequest, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * CommentApiControllerApi - object-oriented interface
 * @export
 * @class CommentApiControllerApi
 * @extends {BaseAPI}
 */
export class CommentApiControllerApi extends BaseAPI {
  /**
   *
   * @param {number} boardId
   * @param {CommentCreateRequest} commentCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommentApiControllerApi
   */
  public createComment(boardId: number, commentCreateRequest: CommentCreateRequest, options?: any) {
    return CommentApiControllerApiFp(this.configuration)
      .createComment(boardId, commentCreateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} boardId
   * @param {number} commentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommentApiControllerApi
   */
  public deleteComment(boardId: number, commentId: number, options?: any) {
    return CommentApiControllerApiFp(this.configuration)
      .deleteComment(boardId, commentId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} boardId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommentApiControllerApi
   */
  public findAll(boardId: number, options?: any) {
    return CommentApiControllerApiFp(this.configuration)
      .findAll(boardId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} boardId
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommentApiControllerApi
   */
  public searchPage(boardId: number, pageable: Pageable, options?: any) {
    return CommentApiControllerApiFp(this.configuration)
      .searchPage(boardId, pageable, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} boardId
   * @param {number} commentId
   * @param {CommentUpdateRequest} commentUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommentApiControllerApi
   */
  public updateComment(boardId: number, commentId: number, commentUpdateRequest: CommentUpdateRequest, options?: any) {
    return CommentApiControllerApiFp(this.configuration)
      .updateComment(boardId, commentId, commentUpdateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ExceptionControllerApi - axios parameter creator
 * @export
 */
export const ExceptionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accessdeniedException: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/exception/accessdenied`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    entrypointException: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/exception/entrypoint`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ExceptionControllerApi - functional programming interface
 * @export
 */
export const ExceptionControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ExceptionControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accessdeniedException(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accessdeniedException(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async entrypointException(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.entrypointException(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * ExceptionControllerApi - factory interface
 * @export
 */
export const ExceptionControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ExceptionControllerApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accessdeniedException(options?: any): AxiosPromise<void> {
      return localVarFp.accessdeniedException(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    entrypointException(options?: any): AxiosPromise<void> {
      return localVarFp.entrypointException(options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * ExceptionControllerApi - object-oriented interface
 * @export
 * @class ExceptionControllerApi
 * @extends {BaseAPI}
 */
export class ExceptionControllerApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExceptionControllerApi
   */
  public accessdeniedException(options?: any) {
    return ExceptionControllerApiFp(this.configuration)
      .accessdeniedException(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExceptionControllerApi
   */
  public entrypointException(options?: any) {
    return ExceptionControllerApiFp(this.configuration)
      .entrypointException(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApiControllerApi - axios parameter creator
 * @export
 */
export const UserApiControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticate: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/user/authenticate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {UserJoinRequestDto} userJoinRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    join: async (userJoinRequestDto: UserJoinRequestDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'userJoinRequestDto' is not null or undefined
      assertParamExists('join', 'userJoinRequestDto', userJoinRequestDto);
      const localVarPath = `/api/v1/user/join`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(userJoinRequestDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {UserLoginRequestDto} userLoginRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (userLoginRequestDto: UserLoginRequestDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'userLoginRequestDto' is not null or undefined
      assertParamExists('login', 'userLoginRequestDto', userLoginRequestDto);
      const localVarPath = `/api/v1/user/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(userLoginRequestDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (authorization: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists('logout', 'authorization', authorization);
      const localVarPath = `/api/v1/user/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} authorization
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: async (authorization: string, refreshToken: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists('refreshToken', 'authorization', authorization);
      // verify required parameter 'refreshToken' is not null or undefined
      assertParamExists('refreshToken', 'refreshToken', refreshToken);
      const localVarPath = `/api/v1/user/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['Authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * UserApiControllerApi - functional programming interface
 * @export
 */
export const UserApiControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authenticate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {UserJoinRequestDto} userJoinRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async join(
      userJoinRequestDto: UserJoinRequestDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserJoinResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.join(userJoinRequestDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {UserLoginRequestDto} userLoginRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      userLoginRequestDto: UserLoginRequestDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(userLoginRequestDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      authorization: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(authorization, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} authorization
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshToken(
      authorization: string,
      refreshToken: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(authorization, refreshToken, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * UserApiControllerApi - factory interface
 * @export
 */
export const UserApiControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserApiControllerApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticate(options?: any): AxiosPromise<UserDto> {
      return localVarFp.authenticate(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UserJoinRequestDto} userJoinRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    join(userJoinRequestDto: UserJoinRequestDto, options?: any): AxiosPromise<UserJoinResponseDto> {
      return localVarFp.join(userJoinRequestDto, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UserLoginRequestDto} userLoginRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(userLoginRequestDto: UserLoginRequestDto, options?: any): AxiosPromise<UserLoginResponseDto> {
      return localVarFp.login(userLoginRequestDto, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(authorization: string, options?: any): AxiosPromise<object> {
      return localVarFp.logout(authorization, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} authorization
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(authorization: string, refreshToken: string, options?: any): AxiosPromise<UserLoginResponseDto> {
      return localVarFp.refreshToken(authorization, refreshToken, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * UserApiControllerApi - object-oriented interface
 * @export
 * @class UserApiControllerApi
 * @extends {BaseAPI}
 */
export class UserApiControllerApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApiControllerApi
   */
  public authenticate(options?: any) {
    return UserApiControllerApiFp(this.configuration)
      .authenticate(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserJoinRequestDto} userJoinRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApiControllerApi
   */
  public join(userJoinRequestDto: UserJoinRequestDto, options?: any) {
    return UserApiControllerApiFp(this.configuration)
      .join(userJoinRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserLoginRequestDto} userLoginRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApiControllerApi
   */
  public login(userLoginRequestDto: UserLoginRequestDto, options?: any) {
    return UserApiControllerApiFp(this.configuration)
      .login(userLoginRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} authorization
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApiControllerApi
   */
  public logout(authorization: string, options?: any) {
    return UserApiControllerApiFp(this.configuration)
      .logout(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} authorization
   * @param {string} refreshToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApiControllerApi
   */
  public refreshToken(authorization: string, refreshToken: string, options?: any) {
    return UserApiControllerApiFp(this.configuration)
      .refreshToken(authorization, refreshToken, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
